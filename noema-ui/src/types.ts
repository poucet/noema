// Types matching the Rust backend
// NOTE: Types with ts-rs are auto-generated in ./generated/
// Re-export commonly used generated types here for convenience
export type { ModelInfo } from "./generated/ModelInfo";
export type { ConversationInfo } from "./generated/ConversationInfo";

// Note: Rust uses #[serde(rename_all = "camelCase")] so variant names are lowercase
export type DisplayContent =
  | { text: string }
  | { image: { data: string; mimeType: string } }
  | { audio: { data: string; mimeType: string } }
  | { toolCall: { name: string; id: string; arguments: unknown } }
  | { toolResult: { id: string; content: DisplayToolResultContent[] } };

export type DisplayToolResultContent =
  | { text: string }
  | { image: { data: string; mimeType: string } }
  | { audio: { data: string; mimeType: string } };

// Information about an alternate response for a span set
export interface AlternateInfo {
  spanId: string;
  modelId: string | null;
  modelDisplayName: string | null;
  messageCount: number;
  isSelected: boolean;
}

export interface DisplayMessage {
  role: "user" | "assistant" | "system";
  content: DisplayContent[];
  // Span set ID this message belongs to (for switching alternates)
  spanSetId?: string;
  // Span ID for this specific message (for fork/edit actions)
  spanId?: string;
  // Available alternates for this message's span set (only populated for assistant messages with alternatives)
  alternates?: AlternateInfo[];
}

// Helper to extract text from content
export function getTextContent(content: DisplayContent[]): string {
  return content
    .map((block) => {
      if ("text" in block) return block.text;
      if ("toolCall" in block) return `[Tool: ${block.toolCall.name}]`;
      if ("toolResult" in block) {
        return block.toolResult.content
          .map((c) => ("text" in c ? c.text : "[Media]"))
          .join("");
      }
      return "";
    })
    .join("");
}

// Check if content has media
export function hasMedia(content: DisplayContent[]): boolean {
  return content.some(
    (block) => "image" in block || "audio" in block
  );
}

// MCP Server types
// "auto" means the backend will probe .well-known to detect OAuth
export type McpAuthType = "none" | "token" | "oauth" | "auto";

export interface McpServerInfo {
  id: string;
  name: string;
  url: string;
  authType: string; // Detected auth type from backend
  isConnected: boolean;
  needsOauthLogin: boolean;
  toolCount: number;
}

export interface McpToolInfo {
  name: string;
  description: string | null;
  serverId: string;
}

export interface AddMcpServerRequest {
  id: string;
  name: string;
  url: string;
  authType: McpAuthType;
  token?: string;
  clientId?: string;
  clientSecret?: string;
  scopes?: string[];
}

// Attachment for sending with messages
export interface Attachment {
  data: string;     // base64 encoded
  mimeType: string; // e.g., "image/png", "audio/mp3"
}

// Supported MIME types for attachments
export const SUPPORTED_IMAGE_TYPES = [
  "image/png",
  "image/jpeg",
  "image/jpg",
  "image/gif",
  "image/webp",
];

export const SUPPORTED_AUDIO_TYPES = [
  "audio/mpeg",
  "audio/mp3",
  "audio/mp4",
  "audio/m4a",
  "audio/wav",
  "audio/webm",
  "audio/ogg",
];

export const SUPPORTED_TEXT_TYPES = [
  "text/plain",
  "text/markdown",
  "text/x-markdown",
];

export const SUPPORTED_DOCUMENT_TYPES = [
  "application/pdf",
];

export const SUPPORTED_ATTACHMENT_TYPES = [
  ...SUPPORTED_IMAGE_TYPES,
  ...SUPPORTED_AUDIO_TYPES,
  ...SUPPORTED_TEXT_TYPES,
  ...SUPPORTED_DOCUMENT_TYPES,
];

export function isImageType(mimeType: string): boolean {
  return SUPPORTED_IMAGE_TYPES.includes(mimeType.toLowerCase());
}

export function isAudioType(mimeType: string): boolean {
  return SUPPORTED_AUDIO_TYPES.includes(mimeType.toLowerCase());
}

export function isTextType(mimeType: string): boolean {
  return SUPPORTED_TEXT_TYPES.includes(mimeType.toLowerCase());
}

export function isPdfType(mimeType: string): boolean {
  return mimeType.toLowerCase() === "application/pdf";
}

export function isSupportedAttachmentType(mimeType: string): boolean {
  return SUPPORTED_ATTACHMENT_TYPES.includes(mimeType.toLowerCase());
}

// Document types are now generated by ts-rs
// Import from ./generated/index.ts:
// - DocumentInfoResponse
// - DocumentTabResponse
// - DocumentContentResponse
