//! Content block types for provenance tracking
//!
//! Content blocks are immutable text content with origin metadata.

use serde::{Deserialize, Serialize};

use crate::storage::ids::{ContentBlockId, UserId};

/// Kind of entity that created the content
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum OriginKind {
    /// Created by a human user
    User,
    /// Generated by an AI assistant
    Assistant,
    /// System-generated content
    System,
    /// Imported from external source
    Import,
}

impl OriginKind {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            OriginKind::User => "user",
            OriginKind::Assistant => "assistant",
            OriginKind::System => "system",
            OriginKind::Import => "import",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "user" => Some(OriginKind::User),
            "assistant" => Some(OriginKind::Assistant),
            "system" => Some(OriginKind::System),
            "import" => Some(OriginKind::Import),
            _ => None,
        }
    }
}

/// Provenance information for content
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ContentOrigin {
    /// What kind of entity created this content
    pub kind: Option<OriginKind>,

    /// User who created or owns this content (if applicable)
    pub user_id: Option<UserId>,

    /// Model ID that generated this content (for assistant-generated)
    pub model_id: Option<String>,

    /// Source identifier (e.g., import URL, external system ID)
    pub source_id: Option<String>,

    /// Parent content this was derived from (for edits, transformations)
    pub parent_id: Option<ContentBlockId>,
}

impl ContentOrigin {
    /// Create origin for user-created content
    pub fn user(user_id: UserId) -> Self {
        Self {
            kind: Some(OriginKind::User),
            user_id: Some(user_id),
            ..Default::default()
        }
    }

    /// Create origin for assistant-generated content
    pub fn assistant(model_id: impl Into<String>) -> Self {
        Self {
            kind: Some(OriginKind::Assistant),
            model_id: Some(model_id.into()),
            ..Default::default()
        }
    }

    /// Create origin for assistant-generated content with user context
    pub fn assistant_for_user(user_id: UserId, model_id: impl Into<String>) -> Self {
        Self {
            kind: Some(OriginKind::Assistant),
            user_id: Some(user_id),
            model_id: Some(model_id.into()),
            ..Default::default()
        }
    }

    /// Create origin for system-generated content
    pub fn system() -> Self {
        Self {
            kind: Some(OriginKind::System),
            ..Default::default()
        }
    }

    /// Create origin for imported content
    pub fn import(source_id: impl Into<String>) -> Self {
        Self {
            kind: Some(OriginKind::Import),
            source_id: Some(source_id.into()),
            ..Default::default()
        }
    }

    /// Set the parent content this was derived from
    pub fn with_parent(mut self, parent_id: ContentBlockId) -> Self {
        self.parent_id = Some(parent_id);
        self
    }
}

/// Type of content stored in a content block
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ContentType {
    /// Plain text content
    #[default]
    Plain,
    /// Markdown-formatted content
    Markdown,
    /// Typst-formatted content
    Typst,
}

impl ContentType {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            ContentType::Plain => "plain",
            ContentType::Markdown => "markdown",
            ContentType::Typst => "typst",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "plain" => Some(ContentType::Plain),
            "markdown" => Some(ContentType::Markdown),
            "typst" => Some(ContentType::Typst),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_origin_kind_roundtrip() {
        for kind in [
            OriginKind::User,
            OriginKind::Assistant,
            OriginKind::System,
            OriginKind::Import,
        ] {
            let s = kind.as_str();
            let parsed = OriginKind::from_str(s).unwrap();
            assert_eq!(parsed, kind);
        }
    }

    #[test]
    fn test_content_origin_user() {
        let origin = ContentOrigin::user(UserId::from_string("user-123"));
        assert_eq!(origin.kind, Some(OriginKind::User));
        assert_eq!(origin.user_id.as_ref().map(|id| id.as_str()), Some("user-123"));
    }

    #[test]
    fn test_content_origin_assistant() {
        let origin = ContentOrigin::assistant("claude-3-opus");
        assert_eq!(origin.kind, Some(OriginKind::Assistant));
        assert_eq!(origin.model_id.as_deref(), Some("claude-3-opus"));
    }

    #[test]
    fn test_content_origin_with_parent() {
        let parent = ContentBlockId::from_string("parent-123");
        let origin = ContentOrigin::user(UserId::from_string("user-1"))
            .with_parent(parent.clone());
        assert_eq!(origin.parent_id.as_ref().map(|id| id.as_str()), Some("parent-123"));
    }

    #[test]
    fn test_content_type_roundtrip() {
        for ct in [ContentType::Plain, ContentType::Markdown, ContentType::Typst] {
            let s = ct.as_str();
            let parsed = ContentType::from_str(s).unwrap();
            assert_eq!(parsed, ct);
        }
    }
}
