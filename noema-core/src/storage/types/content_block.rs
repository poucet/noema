//! Content block types
//!
//! Content blocks are immutable text content with origin metadata.

use serde::{Deserialize, Serialize};

use crate::storage::ids::{ContentBlockId, UserId};

// ============================================================================
// Origin types
// ============================================================================

/// Kind of entity that created the content
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum OriginKind {
    /// Created by a human user
    User,
    /// Generated by an AI assistant
    Assistant,
    /// System-generated content
    System,
    /// Imported from external source
    Import,
}

impl OriginKind {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            OriginKind::User => "user",
            OriginKind::Assistant => "assistant",
            OriginKind::System => "system",
            OriginKind::Import => "import",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "user" => Some(OriginKind::User),
            "assistant" => Some(OriginKind::Assistant),
            "system" => Some(OriginKind::System),
            "import" => Some(OriginKind::Import),
            _ => None,
        }
    }
}

/// Provenance information for content
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ContentOrigin {
    /// What kind of entity created this content
    pub kind: Option<OriginKind>,

    /// User who created or owns this content (if applicable)
    pub user_id: Option<UserId>,

    /// Model ID that generated this content (for assistant-generated)
    pub model_id: Option<String>,

    /// Source identifier (e.g., import URL, external system ID)
    pub source_id: Option<String>,

    /// Parent content this was derived from (for edits, transformations)
    pub parent_id: Option<ContentBlockId>,
}

impl ContentOrigin {
    /// Create origin for user-created content
    pub fn user(user_id: UserId) -> Self {
        Self {
            kind: Some(OriginKind::User),
            user_id: Some(user_id),
            ..Default::default()
        }
    }

    /// Create origin for assistant-generated content
    pub fn assistant(model_id: impl Into<String>) -> Self {
        Self {
            kind: Some(OriginKind::Assistant),
            model_id: Some(model_id.into()),
            ..Default::default()
        }
    }

    /// Create origin for assistant-generated content with user context
    pub fn assistant_for_user(user_id: UserId, model_id: impl Into<String>) -> Self {
        Self {
            kind: Some(OriginKind::Assistant),
            user_id: Some(user_id),
            model_id: Some(model_id.into()),
            ..Default::default()
        }
    }

    /// Create origin for system-generated content
    pub fn system() -> Self {
        Self {
            kind: Some(OriginKind::System),
            ..Default::default()
        }
    }

    /// Create origin for imported content
    pub fn import(source_id: impl Into<String>) -> Self {
        Self {
            kind: Some(OriginKind::Import),
            source_id: Some(source_id.into()),
            ..Default::default()
        }
    }

    /// Set the parent content this was derived from
    pub fn with_parent(mut self, parent_id: ContentBlockId) -> Self {
        self.parent_id = Some(parent_id);
        self
    }
}

/// Type of content stored in a content block
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ContentType {
    /// Plain text content
    #[default]
    Plain,
    /// Markdown-formatted content
    Markdown,
    /// Typst-formatted content
    Typst,
}

impl ContentType {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            ContentType::Plain => "plain",
            ContentType::Markdown => "markdown",
            ContentType::Typst => "typst",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "plain" => Some(ContentType::Plain),
            "markdown" => Some(ContentType::Markdown),
            "typst" => Some(ContentType::Typst),
            _ => None,
        }
    }
}

// ============================================================================
// Content block types
// ============================================================================

/// Core content block data (shared between input and stored forms)
#[derive(Clone, Debug, Default)]
pub struct ContentBlock {
    /// The text content
    pub text: String,

    /// Type of content (plain, markdown, typst)
    pub content_type: ContentType,

    /// Whether this content should only be used locally (not sent to cloud models)
    pub is_private: bool,

    /// Origin/provenance information
    pub origin: ContentOrigin,
}

impl ContentBlock {
    /// Create a new plain text content block
    pub fn plain(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            content_type: ContentType::Plain,
            ..Default::default()
        }
    }

    /// Create a new markdown content block
    pub fn markdown(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            content_type: ContentType::Markdown,
            ..Default::default()
        }
    }

    /// Create a new typst content block
    pub fn typst(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            content_type: ContentType::Typst,
            ..Default::default()
        }
    }

    /// Set the origin information
    pub fn with_origin(mut self, origin: ContentOrigin) -> Self {
        self.origin = origin;
        self
    }

    /// Mark as private (local-only)
    pub fn private(mut self) -> Self {
        self.is_private = true;
        self
    }
}

/// A stored content block with metadata from the database
#[derive(Clone, Debug)]
pub struct StoredContentBlock {
    /// Unique identifier
    pub id: ContentBlockId,

    /// SHA-256 hash of the content
    pub content_hash: String,

    /// The content block data
    pub content: ContentBlock,

    /// When this content was created (unix timestamp ms)
    pub created_at: i64,
}

impl StoredContentBlock {
    /// Get the text content
    pub fn text(&self) -> &str {
        &self.content.text
    }

    /// Get the content type
    pub fn content_type(&self) -> &ContentType {
        &self.content.content_type
    }

    /// Check if private
    pub fn is_private(&self) -> bool {
        self.content.is_private
    }

    /// Get the origin
    pub fn origin(&self) -> &ContentOrigin {
        &self.content.origin
    }
}

/// Result of storing content (may be existing or new)
#[derive(Clone, Debug)]
pub struct StoreResult {
    /// The content block ID
    pub id: ContentBlockId,

    /// The content hash
    pub hash: String,

    /// Whether this was a new insertion (false = deduplicated)
    pub is_new: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_origin_kind_roundtrip() {
        for kind in [
            OriginKind::User,
            OriginKind::Assistant,
            OriginKind::System,
            OriginKind::Import,
        ] {
            let s = kind.as_str();
            let parsed = OriginKind::from_str(s).unwrap();
            assert_eq!(parsed, kind);
        }
    }

    #[test]
    fn test_content_origin_user() {
        let origin = ContentOrigin::user(UserId::from_string("user-123"));
        assert_eq!(origin.kind, Some(OriginKind::User));
        assert_eq!(origin.user_id.as_ref().map(|id| id.as_str()), Some("user-123"));
    }

    #[test]
    fn test_content_origin_assistant() {
        let origin = ContentOrigin::assistant("claude-3-opus");
        assert_eq!(origin.kind, Some(OriginKind::Assistant));
        assert_eq!(origin.model_id.as_deref(), Some("claude-3-opus"));
    }

    #[test]
    fn test_content_origin_with_parent() {
        let parent = ContentBlockId::from_string("parent-123");
        let origin = ContentOrigin::user(UserId::from_string("user-1"))
            .with_parent(parent.clone());
        assert_eq!(origin.parent_id.as_ref().map(|id| id.as_str()), Some("parent-123"));
    }

    #[test]
    fn test_content_type_roundtrip() {
        for ct in [ContentType::Plain, ContentType::Markdown, ContentType::Typst] {
            let s = ct.as_str();
            let parsed = ContentType::from_str(s).unwrap();
            assert_eq!(parsed, ct);
        }
    }
}
