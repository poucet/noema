//! Content block types
//!
//! Content blocks are immutable text content with origin metadata.

use serde::{Deserialize, Serialize};

use crate::storage::ids::{ContentBlockId, UserId};

// ============================================================================
// Origin types
// ============================================================================

/// Kind of entity that created the content
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum OriginKind {
    /// Created by a human user
    User,
    /// Generated by an AI assistant
    Assistant,
    /// System-generated content
    System,
    /// Imported from external source
    Import,
}

impl OriginKind {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            OriginKind::User => "user",
            OriginKind::Assistant => "assistant",
            OriginKind::System => "system",
            OriginKind::Import => "import",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "user" => Some(OriginKind::User),
            "assistant" => Some(OriginKind::Assistant),
            "system" => Some(OriginKind::System),
            "import" => Some(OriginKind::Import),
            _ => None,
        }
    }
}

/// Provenance information for content
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ContentOrigin {
    kind: OriginKind,
    user_id: Option<UserId>,
    model_id: Option<String>,
    source_id: Option<String>,
    parent_id: Option<ContentBlockId>,
}

impl ContentOrigin {
    /// Create origin for user-created content
    pub fn user(user_id: UserId) -> Self {
        Self {
            kind: OriginKind::User,
            user_id: Some(user_id),
            model_id: None,
            source_id: None,
            parent_id: None,
        }
    }

    /// Create origin for assistant-generated content
    pub fn assistant(model_id: impl Into<String>) -> Self {
        Self {
            kind: OriginKind::Assistant,
            user_id: None,
            model_id: Some(model_id.into()),
            source_id: None,
            parent_id: None,
        }
    }

    /// Create origin for assistant-generated content with user context
    pub fn assistant_for_user(user_id: UserId, model_id: impl Into<String>) -> Self {
        Self {
            kind: OriginKind::Assistant,
            user_id: Some(user_id),
            model_id: Some(model_id.into()),
            source_id: None,
            parent_id: None,
        }
    }

    /// Create origin for system-generated content
    pub fn system() -> Self {
        Self {
            kind: OriginKind::System,
            user_id: None,
            model_id: None,
            source_id: None,
            parent_id: None,
        }
    }

    /// Create origin for imported content
    pub fn import(source_id: impl Into<String>) -> Self {
        Self {
            kind: OriginKind::Import,
            user_id: None,
            model_id: None,
            source_id: Some(source_id.into()),
            parent_id: None,
        }
    }

    /// Create origin from an OriginKind (for simple cases)
    pub fn from_kind(kind: OriginKind) -> Self {
        Self {
            kind,
            user_id: None,
            model_id: None,
            source_id: None,
            parent_id: None,
        }
    }

    /// Create origin from database fields
    pub(crate) fn from_db(
        kind: OriginKind,
        user_id: Option<String>,
        model_id: Option<String>,
        source_id: Option<String>,
        parent_id: Option<String>,
    ) -> Self {
        Self {
            kind,
            user_id: user_id.map(UserId::from_string),
            model_id,
            source_id,
            parent_id: parent_id.map(ContentBlockId::from_string),
        }
    }

    /// Set the parent content this was derived from
    pub fn with_parent(mut self, parent_id: ContentBlockId) -> Self {
        self.parent_id = Some(parent_id);
        self
    }

    /// Set the user ID
    pub fn with_user(mut self, user_id: UserId) -> Self {
        self.user_id = Some(user_id);
        self
    }

    /// Set the model ID
    pub fn with_model(mut self, model_id: impl Into<String>) -> Self {
        self.model_id = Some(model_id.into());
        self
    }

    /// Get the origin kind
    pub fn kind(&self) -> OriginKind {
        self.kind
    }

    /// Get the user ID
    pub fn user_id(&self) -> Option<&UserId> {
        self.user_id.as_ref()
    }

    /// Get the model ID
    pub fn model_id(&self) -> Option<&str> {
        self.model_id.as_deref()
    }

    /// Get the source ID
    pub fn source_id(&self) -> Option<&str> {
        self.source_id.as_deref()
    }

    /// Get the parent ID
    pub fn parent_id(&self) -> Option<&ContentBlockId> {
        self.parent_id.as_ref()
    }
}

/// Type of content stored in a content block
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ContentType {
    /// Plain text content
    #[default]
    Plain,
    /// Markdown-formatted content
    Markdown,
    /// Typst-formatted content
    Typst,
}

impl ContentType {
    /// Convert to database string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            ContentType::Plain => "plain",
            ContentType::Markdown => "markdown",
            ContentType::Typst => "typst",
        }
    }

    /// Parse from database string representation
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "plain" => Some(ContentType::Plain),
            "markdown" => Some(ContentType::Markdown),
            "typst" => Some(ContentType::Typst),
            _ => None,
        }
    }
}

// ============================================================================
// Content block types
// ============================================================================

/// Core content block data (shared between input and stored forms)
#[derive(Clone, Debug)]
pub struct ContentBlock {
    /// The text content
    pub text: String,

    /// Type of content (plain, markdown, typst)
    pub content_type: ContentType,

    /// Whether this content should only be used locally (not sent to cloud models)
    pub is_private: bool,

    /// Origin/provenance information
    pub origin: ContentOrigin,
}

impl ContentBlock {
    /// Create a new plain text content block (defaults to System origin)
    pub fn plain(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            content_type: ContentType::Plain,
            is_private: false,
            origin: ContentOrigin::system(),
        }
    }

    /// Create a new markdown content block (defaults to System origin)
    pub fn markdown(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            content_type: ContentType::Markdown,
            is_private: false,
            origin: ContentOrigin::system(),
        }
    }

    /// Create a new typst content block (defaults to System origin)
    pub fn typst(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            content_type: ContentType::Typst,
            is_private: false,
            origin: ContentOrigin::system(),
        }
    }

    /// Set the origin information
    pub fn with_origin(mut self, origin: ContentOrigin) -> Self {
        self.origin = origin;
        self
    }

    /// Mark as private (local-only)
    pub fn private(mut self) -> Self {
        self.is_private = true;
        self
    }
}

/// A hashed content block (content block with its computed hash)
///
/// This extends ContentBlock with its SHA-256 hash for content-addressed storage.
/// Use with `Stored<ContentBlockId, HashedContentBlock>` for the full stored representation.
#[derive(Clone, Debug)]
pub struct HashedContentBlock {
    /// SHA-256 hash of the text content
    pub content_hash: String,

    /// The content block data
    pub content: ContentBlock,
}

impl HashedContentBlock {
    /// Create a new hashed content block
    pub fn new(content_hash: String, content: ContentBlock) -> Self {
        Self {
            content_hash,
            content,
        }
    }

    /// Get the text content
    pub fn text(&self) -> &str {
        &self.content.text
    }

    /// Get the content type
    pub fn content_type(&self) -> &ContentType {
        &self.content.content_type
    }

    /// Check if private
    pub fn is_private(&self) -> bool {
        self.content.is_private
    }

    /// Get the origin
    pub fn origin(&self) -> &ContentOrigin {
        &self.content.origin
    }
}

/// Result of storing content (may be existing or new)
#[derive(Clone, Debug)]
pub struct StoreResult {
    /// The content block ID
    pub id: ContentBlockId,

    /// The content hash
    pub hash: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_origin_kind_roundtrip() {
        for kind in [
            OriginKind::User,
            OriginKind::Assistant,
            OriginKind::System,
            OriginKind::Import,
        ] {
            let s = kind.as_str();
            let parsed = OriginKind::from_str(s).unwrap();
            assert_eq!(parsed, kind);
        }
    }

    #[test]
    fn test_content_origin_user() {
        let origin = ContentOrigin::user(UserId::from_string("user-123"));
        assert_eq!(origin.kind(), OriginKind::User);
        assert_eq!(origin.user_id().map(|id| id.as_str()), Some("user-123"));
    }

    #[test]
    fn test_content_origin_assistant() {
        let origin = ContentOrigin::assistant("claude-3-opus");
        assert_eq!(origin.kind(), OriginKind::Assistant);
        assert_eq!(origin.model_id(), Some("claude-3-opus"));
    }

    #[test]
    fn test_content_origin_with_parent() {
        let parent = ContentBlockId::from_string("parent-123");
        let origin = ContentOrigin::user(UserId::from_string("user-1"))
            .with_parent(parent.clone());
        assert_eq!(origin.parent_id().map(|id| id.as_str()), Some("parent-123"));
    }

    #[test]
    fn test_content_type_roundtrip() {
        for ct in [ContentType::Plain, ContentType::Markdown, ContentType::Typst] {
            let s = ct.as_str();
            let parsed = ContentType::from_str(s).unwrap();
            assert_eq!(parsed, ct);
        }
    }
}
