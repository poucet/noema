//! Model registry - the single source of truth for provider/model handling.
//!
//! Clients should only deal with model IDs like "claude/claude-sonnet-4-5-20250929"
//! and never need to know about provider-specific types.
//!
//! API Key Priority:
//! 1. Settings file (encrypted API keys in settings.toml)
//! 2. Environment variables (CLAUDE_API_KEY, OPENAI_API_KEY, etc.)

use crate::providers::GeneralModelProvider;
use crate::{ChatModel, ModelDefinition, ModelProvider};
use config::Settings;
use std::sync::Arc;

/// A model identifier in the format "provider/model-name"
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ModelId {
    pub provider: String,
    pub model: String,
}

impl ModelId {
    pub fn new(provider: impl Into<String>, model: impl Into<String>) -> Self {
        Self {
            provider: provider.into(),
            model: model.into(),
        }
    }

    pub fn parse(s: &str) -> Option<Self> {
        let (provider, model) = s.split_once('/')?;
        if provider.is_empty() || model.is_empty() {
            return None;
        }
        Some(Self::new(provider, model))
    }
}

impl std::fmt::Display for ModelId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}/{}", self.provider, self.model)
    }
}

impl std::str::FromStr for ModelId {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::parse(s).ok_or_else(|| format!("Invalid model ID '{}': expected 'provider/model'", s))
    }
}

/// Information about a provider (generated by the macro)
#[derive(Clone, Debug)]
pub struct ProviderInfo {
    pub name: &'static str,
    pub api_key_env: Option<&'static str>,
    pub base_url_env: &'static str,
}

/// List all available provider names
pub fn list_providers() -> &'static [ProviderInfo] {
    GeneralModelProvider::all_provider_info()
}

/// Get info for a specific provider
pub fn get_provider_info(name: &str) -> Option<&'static ProviderInfo> {
    list_providers().iter().find(|p| p.name == name)
}

/// Create a chat model from a model ID string like "claude/claude-sonnet-4-5-20250929"
///
/// API keys are loaded with settings taking priority over environment variables.
pub fn create_model(model_id: &str) -> anyhow::Result<Arc<dyn ChatModel + Send + Sync>> {
    let id = ModelId::parse(model_id)
        .ok_or_else(|| anyhow::anyhow!("Invalid model ID '{}': expected 'provider/model'", model_id))?;

    // Load API key from settings (takes priority over env vars)
    let settings = Settings::load();
    let api_key = settings.get_api_key(&id.provider);

    let provider = GeneralModelProvider::from_name_with_key(&id.provider, api_key.as_deref())?;
    provider
        .create_chat_model(&id.model)
        .ok_or_else(|| anyhow::anyhow!("Failed to create model '{}' from provider '{}'", id.model, id.provider))
}

/// Model info with its full ID
#[derive(Clone, Debug)]
pub struct ModelInfo {
    pub id: ModelId,
    pub definition: ModelDefinition,
}

/// List all available models from all providers
///
/// API keys are loaded with settings taking priority over environment variables.
pub async fn list_all_models() -> Vec<(String, anyhow::Result<Vec<ModelInfo>>)> {
    let mut results = Vec::new();
    let settings = Settings::load();

    for info in list_providers() {
        let api_key = settings.get_api_key(info.name);
        let provider_result = GeneralModelProvider::from_name_with_key(info.name, api_key.as_deref());
        let models_result = match provider_result {
            Ok(provider) => match provider.list_models().await {
                Ok(models) => Ok(models
                    .into_iter()
                    .map(|def| ModelInfo {
                        id: ModelId::new(info.name, &def.id),
                        definition: def,
                    })
                    .collect()),
                Err(e) => Err(e),
            },
            Err(e) => Err(e),
        };
        results.push((info.name.to_string(), models_result));
    }

    results
}

/// List models from a specific provider
///
/// API keys are loaded with settings taking priority over environment variables.
pub async fn list_models(provider_name: &str) -> anyhow::Result<Vec<ModelInfo>> {
    let settings = Settings::load();
    let api_key = settings.get_api_key(provider_name);
    let provider = GeneralModelProvider::from_name_with_key(provider_name, api_key.as_deref())?;
    let models = provider.list_models().await?;

    Ok(models
        .into_iter()
        .map(|def| ModelInfo {
            id: ModelId::new(provider_name, &def.id),
            definition: def,
        })
        .collect())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_model_id_parse() {
        let id = ModelId::parse("claude/claude-sonnet-4-5-20250929").unwrap();
        assert_eq!(id.provider, "claude");
        assert_eq!(id.model, "claude-sonnet-4-5-20250929");

        let id = ModelId::parse("gemini/models/gemini-2.5-flash-lite").unwrap();
        assert_eq!(id.provider, "gemini");
        assert_eq!(id.model, "models/gemini-2.5-flash-lite");

        assert!(ModelId::parse("invalid").is_none());
        assert!(ModelId::parse("/model").is_none());
        assert!(ModelId::parse("provider/").is_none());
    }

    #[test]
    fn test_model_id_display() {
        let id = ModelId::new("claude", "claude-sonnet-4-5-20250929");
        assert_eq!(id.to_string(), "claude/claude-sonnet-4-5-20250929");
    }

    #[test]
    fn test_list_providers() {
        let providers = list_providers();
        assert_eq!(providers.len(), 5);
        assert!(providers.iter().any(|p| p.name == "claude"));
        assert!(providers.iter().any(|p| p.name == "gemini"));
        assert!(providers.iter().any(|p| p.name == "openai"));
        assert!(providers.iter().any(|p| p.name == "ollama"));
        assert!(providers.iter().any(|p| p.name == "mistral"));
    }
}
